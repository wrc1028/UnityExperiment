#pragma kernel CalculateVertexes
// 计算顶点法线
#pragma kernel CalculateNormals

RWStructuredBuffer<float3> Vertexes;
RWStructuredBuffer<float3> Normals;
int2 _Subdivision;
Texture2D<float4> _TerrainNoiseTexture;
SamplerState linearClampSampler;

float2 GetUVFromIndex(uint index, int2 subdivision)
{
    int xIndex = index % (subdivision.x + 1);
    int yIndex = floor(index / (subdivision.x + 1));
    return float2((float)xIndex / (subdivision.x + 1), (float)yIndex / (subdivision.y + 1));
}

[numthreads(1024, 1, 1)]
void CalculateVertexes (uint2 id : SV_DISPATCHTHREADID)
{
    float2 uv = GetUVFromIndex(id.x, _Subdivision);
    Vertexes[id.x].y = _TerrainNoiseTexture.SampleLevel(linearClampSampler, uv, 0).r * 5;
}

[numthreads(1024, 1, 1)]
void CalculateNormals (uint2 id : SV_DISPATCHTHREADID)
{
    float2 uv = GetUVFromIndex(id.x, _Subdivision);
    float offsetX = 1.0 / _Subdivision.x;
    float offsetY = 1.0 / _Subdivision.y;

    float upHeight = _TerrainNoiseTexture.SampleLevel(linearClampSampler, uv + float2(0, offsetY), 0).r;
    float downHeight = _TerrainNoiseTexture.SampleLevel(linearClampSampler, uv - float2(0, offsetY), 0).r;
    float leftHeight = _TerrainNoiseTexture.SampleLevel(linearClampSampler, uv - float2(offsetX, 0), 0).r;
    float rightHeight = _TerrainNoiseTexture.SampleLevel(linearClampSampler, uv + float2(offsetX, 0), 0).r;
    
    float3 downToUp = float3(0, upHeight - downHeight, offsetY * 2);
    float3 leftToRight = float3(offsetX * 2, rightHeight - leftHeight, 0);
    Normals[id.x] = normalize(cross(normalize(downToUp), normalize(leftToRight)));
}
